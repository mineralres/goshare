// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: user.proto

#ifndef PROTOBUF_INCLUDED_user_2eproto
#define PROTOBUF_INCLUDED_user_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_user_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_user_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[6]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_user_2eproto();
namespace pb {
class Permission;
class PermissionDefaultTypeInternal;
extern PermissionDefaultTypeInternal _Permission_default_instance_;
class PermissionList;
class PermissionListDefaultTypeInternal;
extern PermissionListDefaultTypeInternal _PermissionList_default_instance_;
class PermissionTreeNode;
class PermissionTreeNodeDefaultTypeInternal;
extern PermissionTreeNodeDefaultTypeInternal _PermissionTreeNode_default_instance_;
class User;
class UserDefaultTypeInternal;
extern UserDefaultTypeInternal _User_default_instance_;
class UserRole;
class UserRoleDefaultTypeInternal;
extern UserRoleDefaultTypeInternal _UserRole_default_instance_;
class UserSession;
class UserSessionDefaultTypeInternal;
extern UserSessionDefaultTypeInternal _UserSession_default_instance_;
}  // namespace pb
namespace google {
namespace protobuf {
template<> ::pb::Permission* Arena::CreateMaybeMessage<::pb::Permission>(Arena*);
template<> ::pb::PermissionList* Arena::CreateMaybeMessage<::pb::PermissionList>(Arena*);
template<> ::pb::PermissionTreeNode* Arena::CreateMaybeMessage<::pb::PermissionTreeNode>(Arena*);
template<> ::pb::User* Arena::CreateMaybeMessage<::pb::User>(Arena*);
template<> ::pb::UserRole* Arena::CreateMaybeMessage<::pb::UserRole>(Arena*);
template<> ::pb::UserSession* Arena::CreateMaybeMessage<::pb::UserSession>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace pb {

enum UserType {
  UT_NORMAL = 0,
  UT_BRANCH_ADMIN = 1,
  UT_SYSTEM_ADMIN = 2,
  UserType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  UserType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool UserType_IsValid(int value);
const UserType UserType_MIN = UT_NORMAL;
const UserType UserType_MAX = UT_SYSTEM_ADMIN;
const int UserType_ARRAYSIZE = UserType_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserType_descriptor();
inline const ::std::string& UserType_Name(UserType value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserType_descriptor(), value);
}
inline bool UserType_Parse(
    const ::std::string& name, UserType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserType>(
    UserType_descriptor(), name, value);
}
enum UserStatus {
  US_NORMAL = 0,
  US_FROZEN = 1,
  US_DELETED = 2,
  UserStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::min(),
  UserStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::google::protobuf::int32>::max()
};
bool UserStatus_IsValid(int value);
const UserStatus UserStatus_MIN = US_NORMAL;
const UserStatus UserStatus_MAX = US_DELETED;
const int UserStatus_ARRAYSIZE = UserStatus_MAX + 1;

const ::google::protobuf::EnumDescriptor* UserStatus_descriptor();
inline const ::std::string& UserStatus_Name(UserStatus value) {
  return ::google::protobuf::internal::NameOfEnum(
    UserStatus_descriptor(), value);
}
inline bool UserStatus_Parse(
    const ::std::string& name, UserStatus* value) {
  return ::google::protobuf::internal::ParseNamedEnum<UserStatus>(
    UserStatus_descriptor(), name, value);
}
// ===================================================================

class User :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.User) */ {
 public:
  User();
  virtual ~User();

  User(const User& from);

  inline User& operator=(const User& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  User(User&& from) noexcept
    : User() {
    *this = ::std::move(from);
  }

  inline User& operator=(User&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const User& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const User* internal_default_instance() {
    return reinterpret_cast<const User*>(
               &_User_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(User* other);
  friend void swap(User& a, User& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline User* New() const final {
    return CreateMaybeMessage<User>(nullptr);
  }

  User* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<User>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const User& from);
  void MergeFrom(const User& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(User* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 roles = 5;
  int roles_size() const;
  void clear_roles();
  static const int kRolesFieldNumber = 5;
  ::google::protobuf::int64 roles(int index) const;
  void set_roles(int index, ::google::protobuf::int64 value);
  void add_roles(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      roles() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_roles();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // .pb.UserType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::pb::UserType type() const;
  void set_type(::pb::UserType value);

  // .pb.UserStatus status = 4;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::pb::UserStatus status() const;
  void set_status(::pb::UserStatus value);

  // @@protoc_insertion_point(class_scope:pb.User)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > roles_;
  mutable std::atomic<int> _roles_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int type_;
  int status_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class Permission :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.Permission) */ {
 public:
  Permission();
  virtual ~Permission();

  Permission(const Permission& from);

  inline Permission& operator=(const Permission& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Permission(Permission&& from) noexcept
    : Permission() {
    *this = ::std::move(from);
  }

  inline Permission& operator=(Permission&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Permission& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Permission* internal_default_instance() {
    return reinterpret_cast<const Permission*>(
               &_Permission_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Permission* other);
  friend void swap(Permission& a, Permission& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Permission* New() const final {
    return CreateMaybeMessage<Permission>(nullptr);
  }

  Permission* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Permission>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Permission& from);
  void MergeFrom(const Permission& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Permission* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string menus = 3;
  int menus_size() const;
  void clear_menus();
  static const int kMenusFieldNumber = 3;
  const ::std::string& menus(int index) const;
  ::std::string* mutable_menus(int index);
  void set_menus(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_menus(int index, ::std::string&& value);
  #endif
  void set_menus(int index, const char* value);
  void set_menus(int index, const char* value, size_t size);
  ::std::string* add_menus();
  void add_menus(const ::std::string& value);
  #if LANG_CXX11
  void add_menus(::std::string&& value);
  #endif
  void add_menus(const char* value);
  void add_menus(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& menus() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_menus();

  // repeated string apis = 4;
  int apis_size() const;
  void clear_apis();
  static const int kApisFieldNumber = 4;
  const ::std::string& apis(int index) const;
  ::std::string* mutable_apis(int index);
  void set_apis(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_apis(int index, ::std::string&& value);
  #endif
  void set_apis(int index, const char* value);
  void set_apis(int index, const char* value, size_t size);
  ::std::string* add_apis();
  void add_apis(const ::std::string& value);
  #if LANG_CXX11
  void add_apis(::std::string&& value);
  #endif
  void add_apis(const char* value);
  void add_apis(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField<::std::string>& apis() const;
  ::google::protobuf::RepeatedPtrField<::std::string>* mutable_apis();

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pb.Permission)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField<::std::string> menus_;
  ::google::protobuf::RepeatedPtrField<::std::string> apis_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::int64 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class PermissionTreeNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.PermissionTreeNode) */ {
 public:
  PermissionTreeNode();
  virtual ~PermissionTreeNode();

  PermissionTreeNode(const PermissionTreeNode& from);

  inline PermissionTreeNode& operator=(const PermissionTreeNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PermissionTreeNode(PermissionTreeNode&& from) noexcept
    : PermissionTreeNode() {
    *this = ::std::move(from);
  }

  inline PermissionTreeNode& operator=(PermissionTreeNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PermissionTreeNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PermissionTreeNode* internal_default_instance() {
    return reinterpret_cast<const PermissionTreeNode*>(
               &_PermissionTreeNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(PermissionTreeNode* other);
  friend void swap(PermissionTreeNode& a, PermissionTreeNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PermissionTreeNode* New() const final {
    return CreateMaybeMessage<PermissionTreeNode>(nullptr);
  }

  PermissionTreeNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PermissionTreeNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PermissionTreeNode& from);
  void MergeFrom(const PermissionTreeNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionTreeNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.PermissionTreeNode children = 3;
  int children_size() const;
  void clear_children();
  static const int kChildrenFieldNumber = 3;
  ::pb::PermissionTreeNode* mutable_children(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::PermissionTreeNode >*
      mutable_children();
  const ::pb::PermissionTreeNode& children(int index) const;
  ::pb::PermissionTreeNode* add_children();
  const ::google::protobuf::RepeatedPtrField< ::pb::PermissionTreeNode >&
      children() const;

  // .pb.Permission permission = 1;
  bool has_permission() const;
  void clear_permission();
  static const int kPermissionFieldNumber = 1;
  const ::pb::Permission& permission() const;
  ::pb::Permission* release_permission();
  ::pb::Permission* mutable_permission();
  void set_allocated_permission(::pb::Permission* permission);

  // bool selected = 2;
  void clear_selected();
  static const int kSelectedFieldNumber = 2;
  bool selected() const;
  void set_selected(bool value);

  // @@protoc_insertion_point(class_scope:pb.PermissionTreeNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pb::PermissionTreeNode > children_;
  ::pb::Permission* permission_;
  bool selected_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class PermissionList :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.PermissionList) */ {
 public:
  PermissionList();
  virtual ~PermissionList();

  PermissionList(const PermissionList& from);

  inline PermissionList& operator=(const PermissionList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  PermissionList(PermissionList&& from) noexcept
    : PermissionList() {
    *this = ::std::move(from);
  }

  inline PermissionList& operator=(PermissionList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const PermissionList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const PermissionList* internal_default_instance() {
    return reinterpret_cast<const PermissionList*>(
               &_PermissionList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(PermissionList* other);
  friend void swap(PermissionList& a, PermissionList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline PermissionList* New() const final {
    return CreateMaybeMessage<PermissionList>(nullptr);
  }

  PermissionList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<PermissionList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const PermissionList& from);
  void MergeFrom(const PermissionList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PermissionList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.Permission list = 1;
  int list_size() const;
  void clear_list();
  static const int kListFieldNumber = 1;
  ::pb::Permission* mutable_list(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::Permission >*
      mutable_list();
  const ::pb::Permission& list(int index) const;
  ::pb::Permission* add_list();
  const ::google::protobuf::RepeatedPtrField< ::pb::Permission >&
      list() const;

  // @@protoc_insertion_point(class_scope:pb.PermissionList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pb::Permission > list_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class UserRole :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.UserRole) */ {
 public:
  UserRole();
  virtual ~UserRole();

  UserRole(const UserRole& from);

  inline UserRole& operator=(const UserRole& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserRole(UserRole&& from) noexcept
    : UserRole() {
    *this = ::std::move(from);
  }

  inline UserRole& operator=(UserRole&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UserRole& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserRole* internal_default_instance() {
    return reinterpret_cast<const UserRole*>(
               &_UserRole_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(UserRole* other);
  friend void swap(UserRole& a, UserRole& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserRole* New() const final {
    return CreateMaybeMessage<UserRole>(nullptr);
  }

  UserRole* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserRole>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserRole& from);
  void MergeFrom(const UserRole& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserRole* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .pb.Permission permissions = 4;
  int permissions_size() const;
  void clear_permissions();
  static const int kPermissionsFieldNumber = 4;
  ::pb::Permission* mutable_permissions(int index);
  ::google::protobuf::RepeatedPtrField< ::pb::Permission >*
      mutable_permissions();
  const ::pb::Permission& permissions(int index) const;
  ::pb::Permission* add_permissions();
  const ::google::protobuf::RepeatedPtrField< ::pb::Permission >&
      permissions() const;

  // string name = 2;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // string discription = 3;
  void clear_discription();
  static const int kDiscriptionFieldNumber = 3;
  const ::std::string& discription() const;
  void set_discription(const ::std::string& value);
  #if LANG_CXX11
  void set_discription(::std::string&& value);
  #endif
  void set_discription(const char* value);
  void set_discription(const char* value, size_t size);
  ::std::string* mutable_discription();
  ::std::string* release_discription();
  void set_allocated_discription(::std::string* discription);

  // int64 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int64 id() const;
  void set_id(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pb.UserRole)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::pb::Permission > permissions_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr discription_;
  ::google::protobuf::int64 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_2eproto;
};
// -------------------------------------------------------------------

class UserSession :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:pb.UserSession) */ {
 public:
  UserSession();
  virtual ~UserSession();

  UserSession(const UserSession& from);

  inline UserSession& operator=(const UserSession& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  UserSession(UserSession&& from) noexcept
    : UserSession() {
    *this = ::std::move(from);
  }

  inline UserSession& operator=(UserSession&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const UserSession& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const UserSession* internal_default_instance() {
    return reinterpret_cast<const UserSession*>(
               &_UserSession_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(UserSession* other);
  friend void swap(UserSession& a, UserSession& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline UserSession* New() const final {
    return CreateMaybeMessage<UserSession>(nullptr);
  }

  UserSession* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<UserSession>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const UserSession& from);
  void MergeFrom(const UserSession& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(UserSession* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int64 roles = 5;
  int roles_size() const;
  void clear_roles();
  static const int kRolesFieldNumber = 5;
  ::google::protobuf::int64 roles(int index) const;
  void set_roles(int index, ::google::protobuf::int64 value);
  void add_roles(::google::protobuf::int64 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
      roles() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
      mutable_roles();

  // string id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  const ::std::string& id() const;
  void set_id(const ::std::string& value);
  #if LANG_CXX11
  void set_id(::std::string&& value);
  #endif
  void set_id(const char* value);
  void set_id(const char* value, size_t size);
  ::std::string* mutable_id();
  ::std::string* release_id();
  void set_allocated_id(::std::string* id);

  // string token = 2;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // .pb.UserType type = 3;
  void clear_type();
  static const int kTypeFieldNumber = 3;
  ::pb::UserType type() const;
  void set_type(::pb::UserType value);

  // .pb.UserStatus status = 4;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  ::pb::UserStatus status() const;
  void set_status(::pb::UserStatus value);

  // int64 deadline = 6;
  void clear_deadline();
  static const int kDeadlineFieldNumber = 6;
  ::google::protobuf::int64 deadline() const;
  void set_deadline(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:pb.UserSession)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int64 > roles_;
  mutable std::atomic<int> _roles_cached_byte_size_;
  ::google::protobuf::internal::ArenaStringPtr id_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  int type_;
  int status_;
  ::google::protobuf::int64 deadline_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_user_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// User

// string id = 1;
inline void User::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::id() const {
  // @@protoc_insertion_point(field_get:pb.User.id)
  return id_.GetNoArena();
}
inline void User::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.User.id)
}
#if LANG_CXX11
inline void User::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.User.id)
}
#endif
inline void User::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.User.id)
}
inline void User::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.User.id)
}
inline ::std::string* User::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:pb.User.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_id() {
  // @@protoc_insertion_point(field_release:pb.User.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:pb.User.id)
}

// string name = 2;
inline void User::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& User::name() const {
  // @@protoc_insertion_point(field_get:pb.User.name)
  return name_.GetNoArena();
}
inline void User::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.User.name)
}
#if LANG_CXX11
inline void User::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.User.name)
}
#endif
inline void User::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.User.name)
}
inline void User::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.User.name)
}
inline ::std::string* User::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:pb.User.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* User::release_name() {
  // @@protoc_insertion_point(field_release:pb.User.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void User::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:pb.User.name)
}

// .pb.UserType type = 3;
inline void User::clear_type() {
  type_ = 0;
}
inline ::pb::UserType User::type() const {
  // @@protoc_insertion_point(field_get:pb.User.type)
  return static_cast< ::pb::UserType >(type_);
}
inline void User::set_type(::pb::UserType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.User.type)
}

// .pb.UserStatus status = 4;
inline void User::clear_status() {
  status_ = 0;
}
inline ::pb::UserStatus User::status() const {
  // @@protoc_insertion_point(field_get:pb.User.status)
  return static_cast< ::pb::UserStatus >(status_);
}
inline void User::set_status(::pb::UserStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:pb.User.status)
}

// repeated int64 roles = 5;
inline int User::roles_size() const {
  return roles_.size();
}
inline void User::clear_roles() {
  roles_.Clear();
}
inline ::google::protobuf::int64 User::roles(int index) const {
  // @@protoc_insertion_point(field_get:pb.User.roles)
  return roles_.Get(index);
}
inline void User::set_roles(int index, ::google::protobuf::int64 value) {
  roles_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.User.roles)
}
inline void User::add_roles(::google::protobuf::int64 value) {
  roles_.Add(value);
  // @@protoc_insertion_point(field_add:pb.User.roles)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
User::roles() const {
  // @@protoc_insertion_point(field_list:pb.User.roles)
  return roles_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
User::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:pb.User.roles)
  return &roles_;
}

// -------------------------------------------------------------------

// Permission

// int64 id = 1;
inline void Permission::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 Permission::id() const {
  // @@protoc_insertion_point(field_get:pb.Permission.id)
  return id_;
}
inline void Permission::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.Permission.id)
}

// string name = 2;
inline void Permission::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Permission::name() const {
  // @@protoc_insertion_point(field_get:pb.Permission.name)
  return name_.GetNoArena();
}
inline void Permission::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.Permission.name)
}
#if LANG_CXX11
inline void Permission::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.Permission.name)
}
#endif
inline void Permission::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.Permission.name)
}
inline void Permission::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.Permission.name)
}
inline ::std::string* Permission::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:pb.Permission.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Permission::release_name() {
  // @@protoc_insertion_point(field_release:pb.Permission.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Permission::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:pb.Permission.name)
}

// repeated string menus = 3;
inline int Permission::menus_size() const {
  return menus_.size();
}
inline void Permission::clear_menus() {
  menus_.Clear();
}
inline const ::std::string& Permission::menus(int index) const {
  // @@protoc_insertion_point(field_get:pb.Permission.menus)
  return menus_.Get(index);
}
inline ::std::string* Permission::mutable_menus(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Permission.menus)
  return menus_.Mutable(index);
}
inline void Permission::set_menus(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.Permission.menus)
  menus_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Permission::set_menus(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:pb.Permission.menus)
  menus_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Permission::set_menus(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  menus_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Permission.menus)
}
inline void Permission::set_menus(int index, const char* value, size_t size) {
  menus_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Permission.menus)
}
inline ::std::string* Permission::add_menus() {
  // @@protoc_insertion_point(field_add_mutable:pb.Permission.menus)
  return menus_.Add();
}
inline void Permission::add_menus(const ::std::string& value) {
  menus_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.Permission.menus)
}
#if LANG_CXX11
inline void Permission::add_menus(::std::string&& value) {
  menus_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.Permission.menus)
}
#endif
inline void Permission::add_menus(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  menus_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.Permission.menus)
}
inline void Permission::add_menus(const char* value, size_t size) {
  menus_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.Permission.menus)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Permission::menus() const {
  // @@protoc_insertion_point(field_list:pb.Permission.menus)
  return menus_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Permission::mutable_menus() {
  // @@protoc_insertion_point(field_mutable_list:pb.Permission.menus)
  return &menus_;
}

// repeated string apis = 4;
inline int Permission::apis_size() const {
  return apis_.size();
}
inline void Permission::clear_apis() {
  apis_.Clear();
}
inline const ::std::string& Permission::apis(int index) const {
  // @@protoc_insertion_point(field_get:pb.Permission.apis)
  return apis_.Get(index);
}
inline ::std::string* Permission::mutable_apis(int index) {
  // @@protoc_insertion_point(field_mutable:pb.Permission.apis)
  return apis_.Mutable(index);
}
inline void Permission::set_apis(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:pb.Permission.apis)
  apis_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void Permission::set_apis(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:pb.Permission.apis)
  apis_.Mutable(index)->assign(std::move(value));
}
#endif
inline void Permission::set_apis(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  apis_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:pb.Permission.apis)
}
inline void Permission::set_apis(int index, const char* value, size_t size) {
  apis_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:pb.Permission.apis)
}
inline ::std::string* Permission::add_apis() {
  // @@protoc_insertion_point(field_add_mutable:pb.Permission.apis)
  return apis_.Add();
}
inline void Permission::add_apis(const ::std::string& value) {
  apis_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:pb.Permission.apis)
}
#if LANG_CXX11
inline void Permission::add_apis(::std::string&& value) {
  apis_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:pb.Permission.apis)
}
#endif
inline void Permission::add_apis(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  apis_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:pb.Permission.apis)
}
inline void Permission::add_apis(const char* value, size_t size) {
  apis_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:pb.Permission.apis)
}
inline const ::google::protobuf::RepeatedPtrField<::std::string>&
Permission::apis() const {
  // @@protoc_insertion_point(field_list:pb.Permission.apis)
  return apis_;
}
inline ::google::protobuf::RepeatedPtrField<::std::string>*
Permission::mutable_apis() {
  // @@protoc_insertion_point(field_mutable_list:pb.Permission.apis)
  return &apis_;
}

// -------------------------------------------------------------------

// PermissionTreeNode

// .pb.Permission permission = 1;
inline bool PermissionTreeNode::has_permission() const {
  return this != internal_default_instance() && permission_ != nullptr;
}
inline void PermissionTreeNode::clear_permission() {
  if (GetArenaNoVirtual() == nullptr && permission_ != nullptr) {
    delete permission_;
  }
  permission_ = nullptr;
}
inline const ::pb::Permission& PermissionTreeNode::permission() const {
  const ::pb::Permission* p = permission_;
  // @@protoc_insertion_point(field_get:pb.PermissionTreeNode.permission)
  return p != nullptr ? *p : *reinterpret_cast<const ::pb::Permission*>(
      &::pb::_Permission_default_instance_);
}
inline ::pb::Permission* PermissionTreeNode::release_permission() {
  // @@protoc_insertion_point(field_release:pb.PermissionTreeNode.permission)
  
  ::pb::Permission* temp = permission_;
  permission_ = nullptr;
  return temp;
}
inline ::pb::Permission* PermissionTreeNode::mutable_permission() {
  
  if (permission_ == nullptr) {
    auto* p = CreateMaybeMessage<::pb::Permission>(GetArenaNoVirtual());
    permission_ = p;
  }
  // @@protoc_insertion_point(field_mutable:pb.PermissionTreeNode.permission)
  return permission_;
}
inline void PermissionTreeNode::set_allocated_permission(::pb::Permission* permission) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete permission_;
  }
  if (permission) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      permission = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, permission, submessage_arena);
    }
    
  } else {
    
  }
  permission_ = permission;
  // @@protoc_insertion_point(field_set_allocated:pb.PermissionTreeNode.permission)
}

// bool selected = 2;
inline void PermissionTreeNode::clear_selected() {
  selected_ = false;
}
inline bool PermissionTreeNode::selected() const {
  // @@protoc_insertion_point(field_get:pb.PermissionTreeNode.selected)
  return selected_;
}
inline void PermissionTreeNode::set_selected(bool value) {
  
  selected_ = value;
  // @@protoc_insertion_point(field_set:pb.PermissionTreeNode.selected)
}

// repeated .pb.PermissionTreeNode children = 3;
inline int PermissionTreeNode::children_size() const {
  return children_.size();
}
inline void PermissionTreeNode::clear_children() {
  children_.Clear();
}
inline ::pb::PermissionTreeNode* PermissionTreeNode::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:pb.PermissionTreeNode.children)
  return children_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::PermissionTreeNode >*
PermissionTreeNode::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:pb.PermissionTreeNode.children)
  return &children_;
}
inline const ::pb::PermissionTreeNode& PermissionTreeNode::children(int index) const {
  // @@protoc_insertion_point(field_get:pb.PermissionTreeNode.children)
  return children_.Get(index);
}
inline ::pb::PermissionTreeNode* PermissionTreeNode::add_children() {
  // @@protoc_insertion_point(field_add:pb.PermissionTreeNode.children)
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::PermissionTreeNode >&
PermissionTreeNode::children() const {
  // @@protoc_insertion_point(field_list:pb.PermissionTreeNode.children)
  return children_;
}

// -------------------------------------------------------------------

// PermissionList

// repeated .pb.Permission list = 1;
inline int PermissionList::list_size() const {
  return list_.size();
}
inline void PermissionList::clear_list() {
  list_.Clear();
}
inline ::pb::Permission* PermissionList::mutable_list(int index) {
  // @@protoc_insertion_point(field_mutable:pb.PermissionList.list)
  return list_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Permission >*
PermissionList::mutable_list() {
  // @@protoc_insertion_point(field_mutable_list:pb.PermissionList.list)
  return &list_;
}
inline const ::pb::Permission& PermissionList::list(int index) const {
  // @@protoc_insertion_point(field_get:pb.PermissionList.list)
  return list_.Get(index);
}
inline ::pb::Permission* PermissionList::add_list() {
  // @@protoc_insertion_point(field_add:pb.PermissionList.list)
  return list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Permission >&
PermissionList::list() const {
  // @@protoc_insertion_point(field_list:pb.PermissionList.list)
  return list_;
}

// -------------------------------------------------------------------

// UserRole

// int64 id = 1;
inline void UserRole::clear_id() {
  id_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 UserRole::id() const {
  // @@protoc_insertion_point(field_get:pb.UserRole.id)
  return id_;
}
inline void UserRole::set_id(::google::protobuf::int64 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:pb.UserRole.id)
}

// string name = 2;
inline void UserRole::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserRole::name() const {
  // @@protoc_insertion_point(field_get:pb.UserRole.name)
  return name_.GetNoArena();
}
inline void UserRole::set_name(const ::std::string& value) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.UserRole.name)
}
#if LANG_CXX11
inline void UserRole::set_name(::std::string&& value) {
  
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.UserRole.name)
}
#endif
inline void UserRole::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.UserRole.name)
}
inline void UserRole::set_name(const char* value, size_t size) {
  
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.UserRole.name)
}
inline ::std::string* UserRole::mutable_name() {
  
  // @@protoc_insertion_point(field_mutable:pb.UserRole.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserRole::release_name() {
  // @@protoc_insertion_point(field_release:pb.UserRole.name)
  
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserRole::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:pb.UserRole.name)
}

// string discription = 3;
inline void UserRole::clear_discription() {
  discription_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserRole::discription() const {
  // @@protoc_insertion_point(field_get:pb.UserRole.discription)
  return discription_.GetNoArena();
}
inline void UserRole::set_discription(const ::std::string& value) {
  
  discription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.UserRole.discription)
}
#if LANG_CXX11
inline void UserRole::set_discription(::std::string&& value) {
  
  discription_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.UserRole.discription)
}
#endif
inline void UserRole::set_discription(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  discription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.UserRole.discription)
}
inline void UserRole::set_discription(const char* value, size_t size) {
  
  discription_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.UserRole.discription)
}
inline ::std::string* UserRole::mutable_discription() {
  
  // @@protoc_insertion_point(field_mutable:pb.UserRole.discription)
  return discription_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserRole::release_discription() {
  // @@protoc_insertion_point(field_release:pb.UserRole.discription)
  
  return discription_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserRole::set_allocated_discription(::std::string* discription) {
  if (discription != nullptr) {
    
  } else {
    
  }
  discription_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), discription);
  // @@protoc_insertion_point(field_set_allocated:pb.UserRole.discription)
}

// repeated .pb.Permission permissions = 4;
inline int UserRole::permissions_size() const {
  return permissions_.size();
}
inline void UserRole::clear_permissions() {
  permissions_.Clear();
}
inline ::pb::Permission* UserRole::mutable_permissions(int index) {
  // @@protoc_insertion_point(field_mutable:pb.UserRole.permissions)
  return permissions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::pb::Permission >*
UserRole::mutable_permissions() {
  // @@protoc_insertion_point(field_mutable_list:pb.UserRole.permissions)
  return &permissions_;
}
inline const ::pb::Permission& UserRole::permissions(int index) const {
  // @@protoc_insertion_point(field_get:pb.UserRole.permissions)
  return permissions_.Get(index);
}
inline ::pb::Permission* UserRole::add_permissions() {
  // @@protoc_insertion_point(field_add:pb.UserRole.permissions)
  return permissions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::pb::Permission >&
UserRole::permissions() const {
  // @@protoc_insertion_point(field_list:pb.UserRole.permissions)
  return permissions_;
}

// -------------------------------------------------------------------

// UserSession

// string id = 1;
inline void UserSession::clear_id() {
  id_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserSession::id() const {
  // @@protoc_insertion_point(field_get:pb.UserSession.id)
  return id_.GetNoArena();
}
inline void UserSession::set_id(const ::std::string& value) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.UserSession.id)
}
#if LANG_CXX11
inline void UserSession::set_id(::std::string&& value) {
  
  id_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.UserSession.id)
}
#endif
inline void UserSession::set_id(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.UserSession.id)
}
inline void UserSession::set_id(const char* value, size_t size) {
  
  id_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.UserSession.id)
}
inline ::std::string* UserSession::mutable_id() {
  
  // @@protoc_insertion_point(field_mutable:pb.UserSession.id)
  return id_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserSession::release_id() {
  // @@protoc_insertion_point(field_release:pb.UserSession.id)
  
  return id_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserSession::set_allocated_id(::std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), id);
  // @@protoc_insertion_point(field_set_allocated:pb.UserSession.id)
}

// string token = 2;
inline void UserSession::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& UserSession::token() const {
  // @@protoc_insertion_point(field_get:pb.UserSession.token)
  return token_.GetNoArena();
}
inline void UserSession::set_token(const ::std::string& value) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:pb.UserSession.token)
}
#if LANG_CXX11
inline void UserSession::set_token(::std::string&& value) {
  
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:pb.UserSession.token)
}
#endif
inline void UserSession::set_token(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:pb.UserSession.token)
}
inline void UserSession::set_token(const char* value, size_t size) {
  
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:pb.UserSession.token)
}
inline ::std::string* UserSession::mutable_token() {
  
  // @@protoc_insertion_point(field_mutable:pb.UserSession.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* UserSession::release_token() {
  // @@protoc_insertion_point(field_release:pb.UserSession.token)
  
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void UserSession::set_allocated_token(::std::string* token) {
  if (token != nullptr) {
    
  } else {
    
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:pb.UserSession.token)
}

// .pb.UserType type = 3;
inline void UserSession::clear_type() {
  type_ = 0;
}
inline ::pb::UserType UserSession::type() const {
  // @@protoc_insertion_point(field_get:pb.UserSession.type)
  return static_cast< ::pb::UserType >(type_);
}
inline void UserSession::set_type(::pb::UserType value) {
  
  type_ = value;
  // @@protoc_insertion_point(field_set:pb.UserSession.type)
}

// .pb.UserStatus status = 4;
inline void UserSession::clear_status() {
  status_ = 0;
}
inline ::pb::UserStatus UserSession::status() const {
  // @@protoc_insertion_point(field_get:pb.UserSession.status)
  return static_cast< ::pb::UserStatus >(status_);
}
inline void UserSession::set_status(::pb::UserStatus value) {
  
  status_ = value;
  // @@protoc_insertion_point(field_set:pb.UserSession.status)
}

// repeated int64 roles = 5;
inline int UserSession::roles_size() const {
  return roles_.size();
}
inline void UserSession::clear_roles() {
  roles_.Clear();
}
inline ::google::protobuf::int64 UserSession::roles(int index) const {
  // @@protoc_insertion_point(field_get:pb.UserSession.roles)
  return roles_.Get(index);
}
inline void UserSession::set_roles(int index, ::google::protobuf::int64 value) {
  roles_.Set(index, value);
  // @@protoc_insertion_point(field_set:pb.UserSession.roles)
}
inline void UserSession::add_roles(::google::protobuf::int64 value) {
  roles_.Add(value);
  // @@protoc_insertion_point(field_add:pb.UserSession.roles)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int64 >&
UserSession::roles() const {
  // @@protoc_insertion_point(field_list:pb.UserSession.roles)
  return roles_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int64 >*
UserSession::mutable_roles() {
  // @@protoc_insertion_point(field_mutable_list:pb.UserSession.roles)
  return &roles_;
}

// int64 deadline = 6;
inline void UserSession::clear_deadline() {
  deadline_ = PROTOBUF_LONGLONG(0);
}
inline ::google::protobuf::int64 UserSession::deadline() const {
  // @@protoc_insertion_point(field_get:pb.UserSession.deadline)
  return deadline_;
}
inline void UserSession::set_deadline(::google::protobuf::int64 value) {
  
  deadline_ = value;
  // @@protoc_insertion_point(field_set:pb.UserSession.deadline)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace pb

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::pb::UserType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::UserType>() {
  return ::pb::UserType_descriptor();
}
template <> struct is_proto_enum< ::pb::UserStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::pb::UserStatus>() {
  return ::pb::UserStatus_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_user_2eproto
